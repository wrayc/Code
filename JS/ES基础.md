Javascript
原始类型：String、Number、Boolean、Null、Undefined、Symbol
引用类型：Object

-----------------------------------------------------------------
typeof 判断类型
instanceof 判断实例的构造函数

一句话：typeof只能判断是否对象或其他原始类型，无法判断是函数还是数组，instanceof可以
判断其构造函数是数组或者函数。

-----------------------------------------------------------------
值类型：String、Number、Boolean、Null、Undefined
引用类型：Date、Array、Function...

按值传递的类型，复制一份存入栈内存，不占用太多内存而且按值传递保证了其访问速度。

按共享传递，是复制其引用，不是复制其值，保证过大的内容不会因为不停复制内容而造成内存浪费。

一句话：值类型和引用类型的主要区别在于其传递过程中，一个是直接复制值，一个是复制引用。

-----------------------------------------------------------------
原型

所有的引用类型（对象，数组，函数），都具有对象特性，即可自由扩展属性（null除外）；
所有的引用类型（对象，数组，函数），都有一个__proto__属性，属性值是一个普通对象；
所有的函数，都有一个prototype属性，属性值也是一个普通的对象；
所有的引用类型（对象，数组，函数），__proto__属性值指向它的构造函数的prototype属性值；


hasOwnProperty()判断是否对象本身属性

-----------------------------------------------------------------
原型链

当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__(即
构造函数的prototype)中寻找；

原型链的终点就是null

原型链中的this： 所有在原型或更高级原型中得到的方法，其中的this在执行时，就指向当前这个
触发事件执行的对象

-----------------------------------------------------------------
作用域
  块级作用域（ES6新增，原来只有全局作用域[windows]和函数作用域[function(){}()]）
  执行上下文
    全局执行上下文（变量定义，函数声明）
    一句话：在JS执行前会先解析代码，解析的时候创建一个全局执行上下文，先把代码中即将执行的变量，函数
    拿出来，变量暂时赋值为undefined，函数则先声明。
    函数执行上下文（变量定义，函数声明，this，arguments）
    一句话：跟全局上下文相似，多出this、arguments和函数的参数
  this
    在执行的时候确认，定义的时候不能确认；
    ES5里，this永远指向最后调用它的那个对象；
    箭头函数的this指向定义时的this，箭头函数本身没有this；
    箭头函数用于解决this===window的问题
作用域链
    自由变量 ：要得到当前作用域没有定义的变量
    作用域链 ：向父级作用域寻找，一层一层找到全局作用域上，找到一个符合的
就结束返回
    闭包：函数作为返回值；函数作为参数传递；
    自由变量从作用域链寻找，依据的是函数定义时的作用域链，不是函数执行时
-----------------------------------------------------------------


-----------------------------------------------------------------
ES6 模块化
    输出唯一对象：export default{}    import xxx from '/xxx'
    输出多个对象：export xx{},xxx{}   import {xx,xxx} from '/xxx'
    class和普通构造函数区别
    添加构造函数 class Name {...}  添加函数 add(){...}
    实现继承 class xxx extends XXX{...}
    一句话：语法上更符合面向对象,构造函数的函数体要放在class的constructor函数中，
constructor为构造器，初始化实例时执行。extends实现继承，子类的constructor一定要执行
super()，以调用父类的constructor
    class xxx {
        constructor(x1,x2){
            this.x1 = x1;
            this.x2 = x2;
        }
        add(){
            return this.x1 + this.x2
        }
    }

-----------------------------------------------------------------
ES6新增数据结构
    Set和Map ：Set是数组的扩展，Map是对象的扩展
    Set类似数组，但是不允许元素重复
    Map类似对象，Key可以为任何数据类型（普通对象Key只能是字符串或数字）
-    
    Set实例的属性和方法
        size：元素数量
        add(value):添加元素，返回实例本身
        delete(value):删除元素，返回布尔值
        has(value):是否实例的元素，返回布尔值
        clear():清除所有元素，不返回
    Set实例的遍历
        keys():返回键名
        values():返回键值
        entries():返回键值对
        forEach():使用回调遍历每个成员
-
    Map实例的属性和方法
        size：元素数量
        set(key,value):添加元素，返回实例本身
        get(key):获取元素，返回元素属性值
        delete(key):删除元素，返回布尔值
        has(key):是否实例的元素，返回布尔值
        clear():清除所有元素，不返回
    Map实例的遍历
        keys():返回键名
        values():返回键值
        entries():返回键值对
        forEach():使用回调遍历每个成员

-----------------------------------------------------------------
